# 正则表达式

正则工具：https://regexper.com/



## 基本字符

### 原义文本字符

a只代表a没有其他意思

```
/a/
```

### 元字符

在正则表达式中有特殊含义的非字母字符

类：指符合某些特性的对象，一个泛指，而不是指某一个字符

#### 字符类

| []    | 匹配所包含的任意一个字符,`[abc]` 把a b c归为一类 |
| ----- | ------------------------------------------------ |
| [^]   | 字符类取反，匹配所不包含的任意一个字符，`[^abc]` |
| [a-z] | 匹配从a到z所包含的任意一个字符                   |

#### 预定义类

| .    | [^\r\n]           | 除了回车符和换行符之外的所有字符 |
| ---- | ----------------- | -------------------------------- |
| \d   | `[0-9]`           | 数字字符                         |
| \D   | `[^0-9]`          | 非数字字符                       |
| \s   | `[\t\n\x0B\f\r]`  | 空白符                           |
| \S   | `[^\t\n\x0B\f\r]` | 非空白符                         |
| \w   | `[a-zA-Z_0-9]`    | 单词字符（字母、数字、下划线）   |
| \W   | `[a-zA-Z_0-9]`    | 非单词字符（字母、数字、下划线） |
|      |                   |                                  |

#### 边界

| ^    | 以啥啥啥开始 |
| ---- | ------------ |
| $    | 以啥啥啥结束 |
| \b   | 单词边界     |
| \B   | 非单词边界   |

#### 量词

匹配连续3次出现abc的字符串，总不能abcabcabc吧

| ？     | 出现0次或者1次（至多出现1次） |
| ------ | ----------------------------- |
| +      | 出现1次或多次（至少出现1次）  |
| *      | 出现0次或者多次（任意次）     |
| {n}    | 出现n次                       |
| {n,}   | 至少出现n次                   |
| {n, m} | 出现n到m此                    |
|        |                               |

例子：用工具图画出`\\d{20}\w\d?\w+\d*\d{3}\w{3,5}\d{3}\`

##### 贪婪模式

例子：

```
'123456'.replace(/\d{2,5}/, 'A')

// 输出结果 : A6
```

##### 非贪婪模式

在量词后加问号

例子：

```
'123456'.replace(/\d{2,5}?/, 'A')
//输出结果 : A3456
```

##### 分组

加()

前边的例子都是一个字符重复几次，如果想让多个字符即字符串重复多次，怎么办？

例子：

```
(word){3}
```

```
'2018/04/18'.replace(/(\d{4})\/(\d{2})\/(\d{2})/, '$1-$2-$3') //"2018-04-18"
```



| .    | 任意字符                                               |
| ---- | ------------------------------------------------------ |
| *    | 匹配前面的子表达式零次或多次                           |
| +    | 匹配前面的子表达式一次或多次                           |
| ？   | 匹配前面的子表达式零次或一次                           |
| ^    | 匹配输入字符串的开始位置                               |
| $    | 匹配输入字符串的结束位置                               |
| \|   | 匹配 x 或 y，`x|y`                                     |
| \    | 转义字符                                               |
| ()   | 分组                                                   |
| []   | 匹配所包含的任意一个字符。`[xyz]  [^xyz] [a-z] [^a-z]` |
| {}   | 匹配确定的 n 次。`{n}{n,}{n,m}`                        |

| \b   | 单词边界                                           |
| ---- | -------------------------------------------------- |
| \d   | 匹配一个数字字符。等价于 [0-9]。                   |
| \D   | 匹配一个非数字字符。等价于 [^0-9]。                |
| \w   | 匹配字母、数字、下划线。等价于'[A-Za-z0-9_]'。     |
| \W   | 匹配非字母、数字、下划线。等价于 '[^A-Za-z0-9_]'。 |
|      |                                                    |
|      |                                                    |



## 修饰符

| i    | ignore - 不区分大小写 |
| ---- | --------------------- |
| g    | global - 全局匹配     |
| m    | multi line - 多行匹配 |



## 前瞻



## 正则表达式的属性、方法

### 属性global ignoreCase multiline

返回值都是boolean

### 属性lastIndex

是当前表达式匹配内容的最后一个字符的下一个位置

```
var reg1 = /\w/;
var reg2 = /\w/gim;
reg1.source;
// 输出: '\w'
reg2.source;
// 输出：'\w'
```

### 属性source

正则表达式的文本字符串

### test

用于测试字符串参数中是否存在匹配正则表达式模式的字符串，如果存在则返回true,否则返回false

### exec

- 使用正则表达式模式对字符串执行搜索，并将更新全局RegExp对象的属性以及反映匹配结果

- 如果没有匹配的文本则返回null, 否则返回一个结果数组
  - index声明匹配文本的第一个字符的位置
  - input 存放被检索的字符串string

非全局调用

- 第一个元素是与正则表达式匹配的文本
- 第二个元素是与正则表达式的一个子表达式（分组group）相匹配的文本
- 第三个元素是与正则表达式的二个子表达式（分组group）相匹配的文本，。。。。一次类推

```
/\d(\w)\d/.exec('1a2b3c4d5e6f')
// ["1a2", "a"]
```



## 字符串可以使用正则表达式的方法

### search

返回第一个匹配结果的index,查找不到返回-1。search忽略全局//g

### match

将检索字符串，以找到一个或者多个与regexp匹配的文本

regexp是否具有标志g对结果影响很大

非全局调用

- 第一个元素是与正则表达式匹配的文本
- 第二个元素是与正则表达式的一个子表达式（分组group）相匹配的文本
- 第三个元素是与正则表达式的二个子表达式（分组group）相匹配的文本，。。。。一次类推

```
'1a2b3c4d5e6f'.match(/\d(\w)\d/)
// ["1a2", "a"]
```

全局调用

- 数组是与正则表达式匹配的所有文本

```
1a2b3c4d5e6f'.match(/\d(\w)\d/g)
// ["1a2", "3c4", "5e6"]
```

### split

```
'a,b,c,d,e'.split(',')
// ['a', 'b', 'c', 'd', 'e']

'a1b2c3d4e'.split(/\d/)
// ['a', 'b', 'c', 'd', 'e']
```



### replace

- replace(str, replaceStr)

- replace(reg, replaceStr)

- replace(reg, function(匹配字符串，正则表达式分组内容【没有分组则没有该参数】，匹配项在字符串中的index, 原字符串))

  ```
  '-1234567.9012'.replace(/(\d)(?=(\d{3})+\.)/g, function($0, $1,$2, $3) {
        console.log($0, $1,$2, $3)
        return $1 + ",";
      }) 
      
  // 1 1 567 1
  // 4 4 567 4
  // "-1,234,567.9012"
  ```

## 常用正则

### 

